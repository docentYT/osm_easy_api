from dataclasses import dataclass, field
from copy import copy

from ..data_classes import User

@dataclass
class Comment():
    comment_created_at: str | None = None
    user: User | None = None
    action: str | None = None
    text: str | None = None
    html: str | None = None

    def __str__(self):
        temp = f"{self.__class__.__name__}("
        for k in self.__dict__:
            temp += f"{k} = {getattr(self, k)}, "
        temp += ")"
        return temp
    
    def to_dict(self) -> dict[str, str]:
        """Returns a dictionary that corresponds to the attributes of the comment. In addition, a 'type':'comment' is added.

        Returns:
            dict[str, str]: A dictionary that represents an comment.
        """
        return_dict = copy(self.__dict__)
        return_dict.update({"type": self.__class__.__name__})
        if self.user:
            return_dict.update({"user": self.user.to_dict()})
        else:
            return_dict.update({"user": None})
        return return_dict

    @classmethod
    def from_dict(cls, dict: dict[str, str]):
        """Creates an comment from the data presented in the dictionary generated by the to_dict() method.

        Args:
            dict (dict[str, str]): Dictionary generated by the to_dict() method.

        Returns:
            Comment: The comment object.
        """
        if not dict.get("type"): 
            raise ValueError("No type key in the dictionary!")
        if dict["type"] != cls.__name__:
            raise ValueError(f'You used incorrect class to create object from given dictionary. Use {dict["type"]}.from_dict() instead of {cls.__name__}.from_dict()')
        comment = cls()
        temp_dict = copy(dict)
        temp_dict.pop("type")
        temp_dict.pop("user")
        comment.__dict__ = temp_dict

        if dict.get("user"):
            comment.user = User.from_dict(dict.get("user"))
        else:
            comment.user = None

        return comment

@dataclass
class Note():
    id: int | None = None
    latitude: str | None = None   # str to prevent rounding values
    longitude: str | None = None
    note_created_at: str | None = None
    open: bool = False
    comments: list[Comment] = field(default_factory=list[Comment])

    def __str__(self):
        temp = f"{self.__class__.__name__}("
        for k in self.__dict__:
            temp += f"{k} = {getattr(self, k)}, "
        temp += ")"
        return temp
    
    def to_dict(self) -> dict[str, str]:
        """Returns a dictionary that corresponds to the attributes of the note. In addition, a 'type':'note' is added.

        Returns:
            dict[str, str]: A dictionary that represents an note.
        """
        return_dict = copy(self.__dict__)
        return_dict.update({"type": self.__class__.__name__})
        return_dict.update({"comments": []})
        for comment in self.comments:
            return_dict["comments"].append(comment.to_dict())
        return return_dict
    
    @classmethod
    def from_dict(cls, dict: dict[str, str]):
        """Creates an note from the data presented in the dictionary generated by the to_dict() method.

        Args:
            dict (dict[str, str]): Dictionary generated by the to_dict() method.

        Returns:
            Note: The note object.
        """
        if not dict.get("type"): 
            raise ValueError("No type key in the dictionary!")
        if dict["type"] != cls.__name__:
            raise ValueError(f'You used incorrect class to create object from given dictionary. Use {dict["type"]}.from_dict() instead of {cls.__name__}.from_dict()')
        note = cls()
        temp_dict = copy(dict)
        temp_dict.pop("type")
        note.__dict__ = temp_dict
        note.__setattr__("comments", [])
        for comment in dict["comments"]:
            note.comments.append(Comment.from_dict(comment))

        return note
        