from dataclasses import dataclass
from copy import copy

from ..data_classes import Tags

@dataclass
class Changeset():
    id: int
    timestamp: str
    open: bool
    user_id: str
    comments_count: str
    changes_count: str
    tags: Tags
    discussion: list[dict] | None = None

    def __str__(self):
        temp = f"{self.__class__.__name__}("
        for k in self.__dict__:
            temp += f"{k} = {getattr(self, k)}, "
        temp += ")"
        return temp
    
    def to_dict(self) -> dict[str, str]:
        """Returns a dictionary that corresponds to the attributes of the changeset. In addition, a 'type':'changeset' is added.

        Returns:
            dict[str, str]: A dictionary that represents an changeset.
        """
        return_dict = copy(self.__dict__)
        return_dict.update({"type": self.__class__.__name__})
        return return_dict
    
    @classmethod
    def from_dict(cls, dict: dict[str, str]):
        """Creates an changeset from the data presented in the dictionary generated by the to_dict() method.

        Args:
            dict (dict[str, str]): Dictionary generated by the to_dict() method.

        Returns:
            Changeset: The changeset object.
        """
        if not dict.get("type"): 
            raise ValueError("No type key in the dictionary!")
        if dict["type"] != cls.__name__:
            raise ValueError(f'You used incorrect class to create object from given dictionary. Use {dict["type"]}.from_dict() instead of {cls.__name__}.from_dict()')
        changeset = cls(-1, "-1", False, "-1", "-1", "-1", Tags(), None)
        temp_dict = copy(dict)
        temp_dict.pop("type")
        changeset.__dict__ = temp_dict
        return changeset